<?php

namespace App\SharedScience\UiQueryBuilder;

use DB;

class UiQueryBuilder
{
    /**
     * takes filters and columns (selects) generated by the front end UI,
     * performs a query on the database and returns query results.
     * @param $record       base record for the query
     * @param $filters      where type conditions to add to the query
     * @param $columns      selects to add to the query
     * @return array        results of the query
     */
    public static function query($record, $filters, $columns) {

        $query = DB::table($record->table);

        // add on selects
        $selects = [];

        $query= self::addIdColumn($query, $record, $selects);
        foreach($columns['rules'] as $column)
        {
            $query = self::addColumn($query, $record, $selects, $column);
        }

        $current_joins = [];

        // add on joins from columns
        foreach($columns['rules'] as $column)
        {
            if (array_key_exists('data', $column) && array_key_exists('joins', $column['data']))
            {
                $query = self::addJoins($query, $record, $current_joins, $column);
            }
        }

        // add on joins from filters
        self::addFiltersJoins($query, $current_joins, $record, $filters);

        // add on filters
        foreach($filters['rules'] as $filter)
        {
            $query = self::addFilter($query, $record, $filters['condition'], $filter);
        }

        return
            [
                'record' => $record,
                'selects' => $selects,
                'results' => $query->get()
            ];
    }

    /**
     * adds an id column (select) to query (id column is
     * required for every query).
     * @param $query        current query
     * @param $record       base record
     * @param $selects      current list of selects
     * @return mixed        new query
     */
    private static function addIdColumn($query, $record, &$selects)
    {
        $join_alias = $record->table;

        $select = 'id';
        $selects[$select] = 'ID';
        return $query->addSelect($join_alias.'.id'.' AS '.$select);
    }

    /**
     * add a column (select) to the query
     * @param $query        current query
     * @param $record       base record
     * @param $selects      current list of selects
     * @param $column       column to add
     * @return mixed        new query
     */
    private static function addColumn($query, $record, &$selects, $column)
    {
        $join_alias = $record->table;

        if (array_key_exists('data', $column) && array_key_exists('joins', $column['data']))
        {
            $joins = $column['data']['joins'];
            $join_alias = last($joins)['alias'];
        }
        $select = $join_alias.'_'.$column['field'];
        $selects[$select] = $column['value'];
        return $query->addSelect($join_alias.'.'.$column['field'].' AS '.$select);
    }

    /**
     * add joins from all filters, processing any child filters recursively
     * @param $query                current query
     * @param $current_joins        a list of already existing joins to prevent duplicates
     * @param $record               base record
     * @param $filters              all filters
     */
    private static function addFiltersJoins(&$query, &$current_joins, $record, $filters)
    {
        foreach($filters['rules'] as $filter)
        {
            // if there is data and data contains info about joins
            if (array_key_exists('data', $filter) && array_key_exists('joins', $filter['data']))
            {
                $query = self::addJoins($query, $record, $current_joins, $filter);
            }

            // if filter contains child filters, obtain child joins recursively
            else if (array_key_exists('rules', $filter))
            {
                self::addFiltersJoins($query, $current_joins, $record, $filter);
            }
        }
    }

    /**
     * adds joins from column (select) or filter to the query. for example,
     * if user chose one of the selects to be emergency contact's first name,
     * then emergency contact join must be added to the query.
     * @param $query                current query
     * @param $record               base record
     * @param $current_joins        a list of already existing joins to prevent duplicates
     * @param $column_or_filter     filter a column, which to check for joins
     * @return mixed                new query
     */
    private static function addJoins($query, $record, &$current_joins, $column_or_filter)
    {
        $join_alias = $record->table;

        if (array_key_exists('data', $column_or_filter) && array_key_exists('joins', $column_or_filter['data']))
        {
            $new_joins = $column_or_filter['data']['joins'];

            foreach($new_joins as $new_join)
            {
                if (!in_array($new_join['alias'], $current_joins))
                {
                    if (array_key_exists('parent_alias', $new_join))
                    {
                        $join_alias = $new_join['parent_alias'];
                    }
                    $query= $query->join($new_join['table'].' AS '.$new_join['alias'], $join_alias.'.'.$new_join['on'], '=', $new_join['alias'].'.'.$new_join['equal']);
                    $join_alias = $new_join['alias'];
                    array_push($current_joins, $join_alias);
                }
                else {
                    $join_alias = $new_join['alias'];
                }
            }
        }
        return $query;
    }

    /**
     * add on filter to the query
     * @param $query        current query
     * @param $record       base record for the query
     * @param $condition    AND or OR
     * @param $filter       unprocessed filter
     * @return              final query
     */
    private static function addFilter($query, $record, $condition, $filter)
    {
        $join_alias = $record->table;

        // if filter contains nested filters
        if (array_key_exists('rules', $filter))
        {
            if ($condition == 'AND')
            {
                $query->where(function ($query) use ($filter, $record)
                {
                    foreach($filter['rules'] as $rule)
                    {
                        self::addFilter($query, $record, $filter['condition'], $rule);
                    }
                });
            }
            else {
                $query->orWhere(function ($query) use ($filter, $record)
                {
                    foreach($filter['rules'] as $rule)
                    {
                        self::addFilter($query, $record, $filter['condition'], $rule);
                    }
                });
            }
        }
        // if there are no nested filters
        else {
            if (array_key_exists('data', $filter) && array_key_exists('joins', $filter['data']))
            {
                $joins = $filter['data']['joins'];
                $join_alias = last($joins)['alias'];
            }
            if ($condition == 'AND')
            {
                $query = self::andWhere($query, $join_alias.'.'.$filter['field'], $filter['operator'], $filter['value']);
            }
            else {
                $query = self::orWhere($query, $join_alias.'.'.$filter['field'], $filter['operator'], $filter['value']);
            }
        }

        return $query;
    }

    /**
     * Converts operators + values to corresponding SQL operators + values
     * @param $operator     string value of operator passed from frontend
     * @return string       SQL equivalent of operator
     */
    private static function andWhere($query, $field, $operator, $value = null)
    {
        switch($operator)
        {

            case "equal": return $query->where($field, '=', $value); //'string', 'number', 'datetime', 'boolean'
            case "not_equal": return $query->where($field, '<>', $value); //'string', 'number', 'datetime', 'boolean'
            case "in" :return $query->whereIn($field, explode(',',$value)); //'string', 'number', 'datetime'
            case "not_in": return $query->whereNotIn($field, explode(',',$value));  //'string', 'number', 'datetime'
            case "less": return $query->where($field, '<', $value); //'number', 'datetime'
            case "less_or_equal": return $query->where($field, '<=', $value); //'number', 'datetime'
            case "greater": return $query->where($field, '>', $value); //'number', 'datetime'
            case "greater_or_equal": $query->where($field, '>=', $value); //'number', 'datetime'
            case "between": return $query->whereBetween($field, $value); //'number', 'datetime'
            case "not_between": return $query->whereNotBetween($field, $value);  //'number', 'datetime'
            case "begins_with": return $query->where($field, 'like', $value."%"); //'string'
            case "not_begins_with": return $query->where($field, 'not like', $value."%"); //'string'
            case "contains": return $query->where($field, 'like', "%".$value."%"); //'string'
            case "not_contains": return $query->where($field, 'not like', "%".$value."%"); //'string'
            case "ends_with": return $query->where($field, 'like', "%".$value); //'string'
            case "not_ends_with": return $query->where($field, 'not like', "%".$value); //'string'
            case "is_empty": return $query->where($field, 'like', ''); //'string'
            case "is_not_empty": return $query->where($field, 'not like', ''); //'string'
            case "is_null": return $query->whereNull($field); //'string', 'number', 'datetime', 'boolean'
            case "is_not_null": return $query->whereNotNull($field); //'string', 'number', 'datetime', 'boolean'
        }
    }

    /**
     * Converts operators + values to corresponding SQL operators + values
     * @param $operator     string value of operator passed from frontend
     * @return string       SQL equivalent of operator
     */
    private static function orWhere($query, $field, $operator, $value = null)
    {
        switch($operator)
        {

            case "equal": return $query->orWhere($field, '=', $value); //'string', 'number', 'datetime', 'boolean'
            case "not_equal": return $query->orWhere($field, '<>', $value); //'string', 'number', 'datetime', 'boolean'
            case "in" :return $query->orWhereIn($field, explode(',',$value)); //'string', 'number', 'datetime'
            case "not_in": return $query->orWhereNotIn($field, explode(',',$value));  //'string', 'number', 'datetime'
            case "less": return $query->orWhere($field, '<', $value); //'number', 'datetime'
            case "less_or_equal": return $query->orWhere($field, '<=', $value); //'number', 'datetime'
            case "greater": return $query->orWhere($field, '>', $value); //'number', 'datetime'
            case "greater_or_equal": $query->orWhere($field, '>=', $value); //'number', 'datetime'
            case "between": return $query->orWhereBetween($field, $value); //'number', 'datetime'
            case "not_between": return $query->orWhereNotBetween($field, $value);  //'number', 'datetime'
            case "begins_with": return $query->orWhere($field, 'like', $value."%"); //'string'
            case "not_begins_with": return $query->orWhere($field, 'not like', $value."%"); //'string'
            case "contains": return $query->orWhere($field, 'like', "%".$value."%"); //'string'
            case "not_contains": return $query->orWhere($field, 'not like', "%".$value."%"); //'string'
            case "ends_with": return $query->orWhere($field, 'like', "%".$value); //'string'
            case "not_ends_with": return $query->orWhere($field, 'not like', "%".$value); //'string'
            case "is_empty": return $query->orWhere($field, 'like', ''); //'string'
            case "is_not_empty": return $query->orWhere($field, 'not like', ''); //'string'
            case "is_null": return $query->orWhereNull($field); //'string', 'number', 'datetime', 'boolean'
            case "is_not_null": return $query->orWhereNotNull($field); //'string', 'number', 'datetime', 'boolean'
        }
    }
}